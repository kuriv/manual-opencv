# 图像存储容器

执行下面的代码，创建一个 512 * 512 大小的 8 位无符号整数的单通道矩阵。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img(512, 512, CV_8UC1);
    return 0;
}
```

执行下面的代码，创建一个 512 * 512 大小的 8 位无符号整数的三通道矩阵，用于存放彩色图像。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img(512, 512, CV_8UC3);
    return 0;
}
```

执行下面的代码，根据输入尺寸和类型构造矩阵。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img(Size(512, 512), CV_8UC3);
    return 0;
}
```

执行下面的代码，利用已有矩阵构造新的矩阵。注意，这种方式构造的矩阵与原矩阵指向的是同一地址。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img1(512, 512, CV_8UC3);
    Mat img2(img1);
    return 0;
}
```

执行下面的代码，从原矩阵中截取新矩阵。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img1(512, 512, CV_8UC3);
    Mat img2(img1, Range(50, 100));
    return 0;
}
```

执行下面的代码，在构造矩阵同时进行赋值。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img1(512, 512, CV_8UC1, Scalar(255));
    Mat img2(512, 512, CV_8UC3, Scalar(0, 0, 255));
    return 0;
}
```

执行下面的代码，利用枚举法为矩阵赋值。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img = (Mat_<int>(3, 3) << 1, 2, 3, 4, 5, 6, 7, 8, 9);
    cout << img << endl;
    return 0;
}
```

执行下面的代码，利用数组为矩阵赋值。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    float arr[] = {5, 6, 7, 8, 1, 2, 3, 4};
    Mat img1(Size(2, 4), CV_32FC1, arr);
    cout << img1 << endl;
    Mat img2(Size(2, 2), CV_32FC2, arr);
    cout << img2 << endl;
    return 0;
}
```

也可以利用类方法对矩阵进行快速赋值。执行下面的代码，构建一个全为 0 的矩阵。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img1 = Mat::zeros(Size(5, 5), CV_8UC1);
    cout << img1 << endl;
    cout << "rows: " << img1.rows << ", cols: " << img1.cols << ", channels: " << img1.channels() << endl;
    imshow("IMG1", img1);
    Mat img2 = Mat::zeros(Size(5, 5), CV_8UC3);
    cout << img2 << endl;
    cout << "rows: " << img2.rows << ", cols: " << img2.cols << ", channels: " << img2.channels() << endl;
    imshow("IMG2", img2);
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

执行下面的代码，构建一个全为 1 的矩阵。注意，三通道中仅第一个通道被赋值为 1 ，其余通道均为 0 。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img1 = Mat::ones(Size(5, 5), CV_8UC1);
    cout << img1 << endl;
    imshow("IMG1", img1);
    Mat img2 = Mat::ones(Size(5, 5), CV_8UC3);
    cout << img2 << endl;
    imshow("IMG2", img2);
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

执行下面的代码，构建一个单位矩阵。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img1 = Mat::eye(Size(5, 5), CV_8UC1);
    cout << img1 << endl;
    imshow("IMG1", img1);
    Mat img2 = Mat::eye(Size(5, 5), CV_8UC3);
    cout << img2 << endl;
    imshow("IMG2", img2);
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

执行下面的代码，构建对角矩阵。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat diag = (Mat_<int>(1, 5) << 1, 2, 3, 4, 5);
    Mat img = Mat::diag(diag);
    cout << img << endl;
    imshow("IMG", img);
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

执行下面的代码，对矩阵进行加减乘除运算。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat a = (Mat_<int>(3, 3) << 1, 2, 3, 4, 5, 6, 7, 8, 9);
    Mat b = (Mat_<int>(3, 3) << 9, 8, 7, 6, 5, 4, 3, 2, 1);
    Mat img;
    img = a + b;
    cout << img << endl;
    img = a - b;
    cout << img << endl;
    img = a * 2;
    cout << img << endl;
    img = a / 2;
    cout << img << endl;
    return 0;
}
```

执行下面的代码，对两个矩阵进行乘法运算。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat a = (Mat_<float>(2, 2) << 1.0, 2.0, 3.0, 4.0);
    Mat b = (Mat_<float>(2, 2) << 9.0, 8.0, 7.0, 6.0);
    Mat img;
    double dot;
    img = a * b;
    cout << img << endl;
    img = a.mul(b);
    cout << img << endl;
    dot = a.dot(b);
    cout << dot << endl;
    return 0;
}
```

执行下面的代码，分别获取矩阵的相关信息。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img(3, 4, CV_8UC3);
    cout << "rows: " << img.rows << endl;
    cout << "cols: " << img.cols << endl;
    cout << "step: " << img.step << endl;
    cout << "elemSize: " << img.elemSize() << endl;
    cout << "total: " << img.total() << endl;
    cout << "channels: " << img.channels() << endl;
    return 0;
}
```

执行下面的代码，获取单通道矩阵中元素的信息。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img = (Mat_<uchar>(3, 3) << 1, 2, 3, 4, 5, 6, 7, 8, 9);
    cout << (int)img.at<uchar>(1, 1) << endl;
    return 0;
}
```

执行下面的代码，获取三通道矩阵中元素的信息。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img = Mat(3, 3, CV_8UC3, Scalar(0, 0, 255));
    Vec3b bgr = img.at<Vec3b>(1, 1);
    cout << bgr << endl;
    cout << (int)bgr[0] << endl;
    cout << (int)bgr[1] << endl;
    cout << (int)bgr[2] << endl;
    return 0;
}
```

也可以通过指针方式读取矩阵中元素的信息。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img = Mat(3, 3, CV_8UC3, Scalar(0, 0, 255));
    int rows = img.rows;
    int cols = img.cols;
    uchar *p;
    int i, j;
    for (i = 0; i < rows; i++)
    {
        p = img.ptr<uchar>(i);
        for (j = 0; j < cols; j++)
        {
            cout << (int)*p++ << (int)*p++ << (int)*p++ << endl;
        }
    }
    return 0;
}
```

