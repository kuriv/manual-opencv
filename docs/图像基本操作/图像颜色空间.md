# 图像颜色空间

执行下面的代码，可以转换指定图像的颜色模型。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img = imread("demo.jpg");
    Mat gray, hsv, yuv, lab;
    if (img.empty())
    {
        cout << "Could not load image.\n" << endl;
        return -1;
    }
    imshow("IMG", img);
    cvtColor(img, gray, COLOR_BGR2GRAY);
    imshow("GRAY", gray);
    cvtColor(img, hsv, COLOR_BGR2HSV);
    imshow("HSV", hsv);
    cvtColor(img, yuv, COLOR_BGR2YUV);
    imshow("YUV", yuv);
    cvtColor(img, lab, COLOR_BGR2Lab);
    imshow("LAB", lab);
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

执行下面的代码，可以将图像从 8 位无符号整数类型转换为 32 位浮点数类型。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img = imread("demo.jpg");
    Mat img32;
    if (img.empty())
    {
        cout << "Could not load image.\n" << endl;
        return -1;
    }
    imshow("IMG", img);
    img.convertTo(img32, CV_32F);
    imshow("IMG32", img32);
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

执行下面的代码，将图像从三通道中分离并展示。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img = imread("demo.jpg");
    vector<Mat> matrix;
    if (img.empty())
    {
        cout << "Could not load image.\n" << endl;
        return -1;
    }
    imshow("IMG", img);
    split(img, matrix);
    imshow("B", matrix[0]);
    imshow("G", matrix[1]);
    imshow("R", matrix[2]);
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

执行下面的代码，修改图像通道内容然后合并。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img = imread("demo.jpg");
    vector<Mat> matrix;
    if (img.empty())
    {
        cout << "Could not load image.\n" << endl;
        return -1;
    }
    imshow("BEFORE", img);
    split(img, matrix);
    matrix[0] = 0;
    merge(matrix, img);
    imshow("AFTER", img);
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

也可以指定要调整或混合的通道。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img = imread("demo.jpg");
    Mat result = img.clone();
    int from_to[] = {0, 2, 1, 1, 2, 0};
    if (img.empty())
    {
        cout << "Could not load image.\n" << endl;
        return -1;
    }
    imshow("IMG", img);
    mixChannels(&img, 1, &result, 1, from_to, 3);
    imshow("RESULT", result);
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

