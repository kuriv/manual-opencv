# 图像像素操作处理

执行下面的代码，输出单通道图像中的像素最小值、最大值以及分别所在的坐标。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    float arr[] = {1, 4, 7, 10, 2, 5, 8, 11, 3, 6, 9, 12};
    Mat img = Mat(3, 4, CV_32FC1, arr);
    double minVal, maxVal;
    Point minIdx, maxIdx;
    cout << img << endl;
    imshow("IMG", img);
    minMaxLoc(img, &minVal, &maxVal, &minIdx, &maxIdx);
    cout << "minVal = " << minVal << ", maxVal = " << maxVal << "." << endl;
    cout << "minIdx = " << minIdx << ", maxIdx = " << maxIdx << "." << endl;
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

执行下面的代码，输出三通道图像在每个通道中的像素最小值、最大值以及分别所在的坐标。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    float arr[] = {1, 4, 7, 10, 2, 5, 8, 11, 3, 6, 9, 12};
    Mat img = Mat(2, 2, CV_32FC3, arr);
    vector<Mat> matrix;
    int i;
    double minVal, maxVal;
    Point minIdx, maxIdx;
    cout << img << endl;
    imshow("IMG", img);
    split(img, matrix);
    for (i = 0; i < img.channels(); i++)
    {
        cout << matrix[i] << endl;
        minMaxLoc(matrix[i], &minVal, &maxVal, &minIdx, &maxIdx);
        cout << "Channer #" << i << ":" << endl;
        cout << "minVal = " << minVal << ", maxVal = " << maxVal << "." << endl;
        cout << "minIdx = " << minIdx << ", maxIdx = " << maxIdx << "." << endl;
    }
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

图像的平均值表示图像整体的亮暗程度，图像平均值越大，则图像整体越亮。标准差表示图像中明暗变化的对比程度，标准差越大，表示图像中明暗变化越明显。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img = imread("demo.jpg");
    Mat mean, stddev;
    if (img.empty())
    {
        cout << "Could not load image.\n" << endl;
        return -1;
    }
    imshow("IMG", img);
    meanStdDev(img, mean, stddev);
    cout << "mean: " << mean << endl;
    cout << "stddev: " << stddev << endl;
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

执行下面的代码，对两个单通道图像矩阵进行比较运算。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    float arr1[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
    float arr2[] = {12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
    Mat img1 = Mat(3, 4, CV_32FC1, arr1);
    cout << img1 << endl;
    Mat img2 = Mat(3, 4, CV_32FC1, arr2);
    cout << img2 << endl;
    Mat max, min;
    cv::max(img1, img2, max);
    cout << max << endl;
    cv::min(img1, img2, min);
    cout << min << endl;
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

执行下面的代码，对两个三通道图像矩阵进行比较运算。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    float arr1[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
    float arr2[] = {12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
    Mat img1 = Mat(2, 2, CV_32FC3, arr1);
    cout << img1 << endl;
    Mat img2 = Mat(2, 2, CV_32FC3, arr2);
    cout << img2 << endl;
    Mat max, min;
    cv::max(img1, img2, max);
    cout << max << endl;
    cv::min(img1, img2, min);
    cout << min << endl;
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

执行下面的代码，可以对图像进行像素逻辑操作。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img1 = Mat::zeros(512, 512, CV_8UC3);
    Mat img2 = Mat::zeros(512, 512, CV_8UC3);
    Mat result;
    rectangle(img1, Rect(100, 100, 80, 80), Scalar(0, 255, 255), -1);
    rectangle(img2, Rect(150, 150, 80, 80), Scalar(255, 255, 0), -1);
    imshow("IMG1", img1);
    imshow("IMG2", img2);
    bitwise_and(img1, img2, result);
    imshow("AND", result);
    bitwise_or(img1, img2, result);
    imshow("OR", result);
    bitwise_xor(img1, img2, result);
    imshow("XOR", result);
    bitwise_not(img1, result);
    imshow("NOT", result);
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

只有黑色和白色的图像称为二值图像，将非二值图像经过计算变成二值图像的过程称为图像的二值化。

```cpp
```

