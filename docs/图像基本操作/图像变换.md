# 图像变换

执行下面的代码，将两张图像进行上下连接。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img1 = imread("concat_1.jpg");
    Mat img2 = imread("concat_2.jpg");
    Mat result;
    if (img1.empty() || img2.empty())
    {
        cout << "Could not load image.\n" << endl;
        return -1;
    }
    imshow("IMG1", img1);
    imshow("IMG2", img2);
    vconcat(img1, img2, result);
    imshow("VCONCAT", result);
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

执行下面的代码，将两张图像进行左右连接。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img1 = imread("concat_1.jpg");
    Mat img2 = imread("concat_2.jpg");
    Mat result;
    if (img1.empty() || img2.empty())
    {
        cout << "Could not load image.\n" << endl;
        return -1;
    }
    imshow("IMG1", img1);
    imshow("IMG2", img2);
    hconcat(img1, img2, result);
    imshow("HCONCAT", result);
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

执行下面的代码，将图像进行等比例放大和缩小。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img = imread("demo.jpg");
    Mat zoomin, zoomout;
    if (img.empty())
    {
        cout << "Could not load image.\n" << endl;
        return -1;
    }
    imshow("IMG", img);
    resize(img, zoomin, Size(img.cols / 2, img.rows / 2), 0, 0, INTER_LINEAR);
    imshow("ZOOMIN", zoomin);
    resize(img, zoomout, Size(img.cols * 1.5, img.rows * 1.5), 0, 0, INTER_LINEAR);
    imshow("ZOOMOUT", zoomout);
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

执行下面的代码，将原图像分别进行垂直翻转、水平翻转以及 180° 旋转。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img = imread("demo.jpg");
    Mat img1, img2, img3;
    if (img.empty())
    {
        cout << "Could not load image.\n" << endl;
        return -1;
    }
    imshow("IMG", img);
    flip(img, img1, 0);
    imshow("IMG1", img1);
    flip(img, img2, 1);
    imshow("IMG2", img2);
    flip(img, img3, -1);
    imshow("IMG3", img3);
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

要实现图像的旋转，首先需要确定旋转角度和旋转中心，之后确定旋转矩阵，最终通过仿射变换实现图像旋转。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img = imread("demo.jpg");
    if (img.empty())
    {
        cout << "Could not load image.\n" << endl;
        return -1;
    }
    imshow("IMG", img);
    double angle = 30;
    Size size(img.rows, img.cols);
    Point2f center(img.rows / 2.0, img.cols / 2.0);
    Mat rotation;
    Mat result;
    rotation = getRotationMatrix2D(center, angle, 1);
    warpAffine(img, result, rotation, size);
    imshow("ROTATION", result);
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

也可以自定义仿射变换参数。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img = imread("demo.jpg");
    if (img.empty())
    {
        cout << "Could not load image.\n" << endl;
        return -1;
    }
    imshow("IMG", img);
    Size size(img.rows, img.cols);
    Point2f src[3];
    Point2f dst[3];
    Mat rotation;
    Mat result;
    src[0] = Point2f(0, 0);
    src[1] = Point2f(0, (float)(img.cols - 1));
    src[2] = Point2f((float)(img.rows - 1), (float)(img.cols - 1));
    dst[0] = Point2f((float)(img.rows) * 0.1, (float)(img.cols) * 0.1);
    dst[1] = Point2f((float)(img.rows) * 0.2, (float)(img.cols) * 0.8);
    dst[2] = Point2f((float)(img.rows) * 0.8, (float)(img.cols) * 0.8);
    rotation = getAffineTransform(src, dst);
    warpAffine(img, result, rotation, size);
    imshow("ROTATION", result);
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

透视变换是按照物体成像投影规律进行变换，即将物体重新投影到新的成像平面。

```cpp

```

极坐标变化就是将图像在直角坐标系与极坐标系中互相变换。

```cpp
```

