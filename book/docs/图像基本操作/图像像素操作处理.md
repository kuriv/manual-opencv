# 图像像素操作处理

执行下面的代码，输出单通道图像中的像素最小值、最大值以及分别所在的坐标。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    float arr[] = {1, 4, 7, 10, 2, 5, 8, 11, 3, 6, 9, 12};
    Mat img = Mat(3, 4, CV_32FC1, arr);
    double minVal, maxVal;
    Point minIdx, maxIdx;
    cout << img << endl;
    imshow("IMG", img);
    minMaxLoc(img, &minVal, &maxVal, &minIdx, &maxIdx);
    cout << "minVal = " << minVal << ", maxVal = " << maxVal << "." << endl;
    cout << "minIdx = " << minIdx << ", maxIdx = " << maxIdx << "." << endl;
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

执行下面的代码，输出三通道图像在每个通道中的像素最小值、最大值以及分别所在的坐标。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    float arr[] = {1, 4, 7, 10, 2, 5, 8, 11, 3, 6, 9, 12};
    Mat img = Mat(2, 2, CV_32FC3, arr);
    vector<Mat> matrix;
    int i;
    double minVal, maxVal;
    Point minIdx, maxIdx;
    cout << img << endl;
    imshow("IMG", img);
    split(img, matrix);
    for (i = 0; i < img.channels(); i++)
    {
        cout << matrix[i] << endl;
        minMaxLoc(matrix[i], &minVal, &maxVal, &minIdx, &maxIdx);
        cout << "Channer #" << i << ":" << endl;
        cout << "minVal = " << minVal << ", maxVal = " << maxVal << "." << endl;
        cout << "minIdx = " << minIdx << ", maxIdx = " << maxIdx << "." << endl;
    }
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

图像的平均值表示图像整体的亮暗程度，图像平均值越大，则图像整体越亮。标准差表示图像中明暗变化的对比程度，标准差越大，表示图像中明暗变化越明显。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img = imread("demo.jpg");
    Mat mean, stddev;
    if (img.empty())
    {
        cout << "Could not load image.\n" << endl;
        return -1;
    }
    imshow("IMG", img);
    meanStdDev(img, mean, stddev);
    cout << "mean: " << mean << endl;
    cout << "stddev: " << stddev << endl;
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

执行下面的代码，对两个单通道图像矩阵进行比较运算。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    float arr1[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
    float arr2[] = {12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
    Mat img1 = Mat(3, 4, CV_32FC1, arr1);
    cout << img1 << endl;
    Mat img2 = Mat(3, 4, CV_32FC1, arr2);
    cout << img2 << endl;
    Mat max, min;
    cv::max(img1, img2, max);
    cout << max << endl;
    cv::min(img1, img2, min);
    cout << min << endl;
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

执行下面的代码，对两个三通道图像矩阵进行比较运算。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    float arr1[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
    float arr2[] = {12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
    Mat img1 = Mat(2, 2, CV_32FC3, arr1);
    cout << img1 << endl;
    Mat img2 = Mat(2, 2, CV_32FC3, arr2);
    cout << img2 << endl;
    Mat max, min;
    cv::max(img1, img2, max);
    cout << max << endl;
    cv::min(img1, img2, min);
    cout << min << endl;
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

执行下面的代码，可以对图像进行像素逻辑操作。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img1 = Mat::zeros(512, 512, CV_8UC3);
    Mat img2 = Mat::zeros(512, 512, CV_8UC3);
    Mat result;
    rectangle(img1, Rect(100, 100, 80, 80), Scalar(0, 255, 255), -1);
    rectangle(img2, Rect(150, 150, 80, 80), Scalar(255, 255, 0), -1);
    imshow("IMG1", img1);
    imshow("IMG2", img2);
    bitwise_and(img1, img2, result);
    imshow("AND", result);
    bitwise_or(img1, img2, result);
    imshow("OR", result);
    bitwise_xor(img1, img2, result);
    imshow("XOR", result);
    bitwise_not(img1, result);
    imshow("NOT", result);
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

只有黑色和白色的图像称为二值图像，将非二值图像经过计算变成二值图像的过程称为图像的二值化。执行下面的代码，将彩色图像进行 BINARY 二值化处理。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img = imread("demo.jpg");
    Mat img_b, img_bv;
    if (img.empty())
    {
        cout << "Could not load image.\n" << endl;
        return -1;
    }
    imshow("IMG", img);
    threshold(img, img_b, 128, 255, THRESH_BINARY);
    imshow("IMG_BINARY", img_b);
    threshold(img, img_bv, 128, 255, THRESH_BINARY_INV);
    imshow("IMG_BINARY_INV", img_bv);
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

执行下面的代码，将灰度图像进行 BINARY 二值化处理。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img = imread("demo.jpg");
    Mat gray;
    Mat img_b, img_bv;
    if (img.empty())
    {
        cout << "Could not load image.\n" << endl;
        return -1;
    }
    imshow("IMG", img);
    cvtColor(img, gray, COLOR_BGR2GRAY);
    imshow("GRAY", gray);
    threshold(gray, img_b, 128, 255, THRESH_BINARY);
    imshow("GRAY_BINARY", img_b);
    threshold(gray, img_bv, 128, 255, THRESH_BINARY_INV);
    imshow("GRAY_BINARY_INV", img_bv);
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

执行下面的代码，将灰度图像进行 TOZERO 变换。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img = imread("demo.jpg");
    Mat gray;
    Mat img_tz, img_tzv;
    if (img.empty())
    {
        cout << "Could not load image.\n" << endl;
        return -1;
    }
    imshow("IMG", img);
    cvtColor(img, gray, COLOR_BGR2GRAY);
    imshow("GRAY", gray);
    threshold(gray, img_tz, 128, 255, THRESH_TOZERO);
    imshow("GRAY_TOZERO", img_tz);
    threshold(gray, img_tzv, 128, 255, THRESH_TOZERO_INV);
    imshow("GRAY_TOZERO_INV", img_tzv);
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

执行下面的代码，将灰度图像进行 TRUNC 变换。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img = imread("demo.jpg");
    Mat gray;
    Mat img_tc;
    if (img.empty())
    {
        cout << "Could not load image.\n" << endl;
        return -1;
    }
    imshow("IMG", img);
    cvtColor(img, gray, COLOR_BGR2GRAY);
    imshow("GRAY", gray);
    threshold(gray, img_tc, 128, 255, THRESH_TRUNC);
    imshow("GRAY_TRUNC", img_tc);
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

执行下面的代码，将灰度图像进行自适应二值化处理。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    Mat img = imread("demo.jpg");
    Mat gray;
    Mat img_mean, img_gauss;
    if (img.empty())
    {
        cout << "Could not load image.\n" << endl;
        return -1;
    }
    imshow("IMG", img);
    cvtColor(img, gray, COLOR_BGR2GRAY);
    imshow("GRAY", gray);
    adaptiveThreshold(gray, img_mean, 255, ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY, 55, 0);
    imshow("IMG_MEAN", img_mean);
    adaptiveThreshold(gray, img_gauss, 255, ADAPTIVE_THRESH_GAUSSIAN_C, THRESH_BINARY, 55, 0);
    imshow("IMG_GAUSS", img_gauss);
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

如果需要和多个阈值进行比较，就需要用到显示查找表。

```cpp
#include <opencv2/opencv.hpp>
#include <iostream>

using namespace cv;
using namespace std;

int main(int argc, char const *argv[])
{
    uchar arr1[256], arr2[256], arr3[256];
    int i;
    for (i = 0; i < 256; i++)
    {
        if (i <= 100)
        {
            arr1[i] = 0;
        }
        else if (i > 100 && i < 200)
        {
            arr1[i] = 100;
        }
        else
        {
            arr1[i] = 255;
        }
    }
    Mat lut1(1, 256, CV_8UC1, arr1);
    for (i = 0; i < 256; i++)
    {
        if (i <= 100)
        {
            arr2[i] = 0;
        }
        else if (i > 100 && i <= 150)
        {
            arr2[i] = 100;
        }
        else if (i > 150 && i <= 200)
        {
            arr2[i] = 150;
        }
        else
        {
            arr2[i] = 255;
        }
    }
    Mat lut2(1, 256, CV_8UC1, arr2);
    for (i = 0; i < 256; i++)
    {
        if (i <= 100)
        {
            arr3[i] = 100;
        }
        else if (i > 100 && i < 200)
        {
            arr3[i] = 200;
        }
        else
        {
            arr3[i] = 255;
        }
    }
    Mat lut3(1, 256, CV_8UC1, arr3);
    Mat img = imread("demo.jpg");
    Mat img_lut1, img_lut2, img_lut3;
    Mat gray;
    Mat gray_lut1;
    if (img.empty())
    {
        cout << "Could not load image.\n" << endl;
        return -1;
    }
    imshow("IMG", img);
    LUT(img, lut1, img_lut1);
    imshow("IMG_LUT1", img_lut1);
    LUT(img, lut2, img_lut2);
    imshow("IMG_LUT2", img_lut2);
    LUT(img, lut3, img_lut3);
    imshow("IMG_LUT3", img_lut3);
    cvtColor(img, gray, COLOR_BGR2GRAY);
    imshow("GRAY", gray);
    LUT(gray, lut1, gray_lut1);
    imshow("GRAY_LUT1", gray_lut1);
    waitKey(0);
    destroyAllWindows();
    return 0;
}
```

