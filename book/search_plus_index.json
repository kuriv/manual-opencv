{"./":{"url":"./","title":"OpenCV","keywords":"","body":"OpenCV OpenCV 是世界上最大的计算机视觉库。 "},"docs/安装 OpenCV.html":{"url":"docs/安装 OpenCV.html","title":"安装 OpenCV","keywords":"","body":"安装 OpenCV 要了解更多选择，可以前往 OpenCV 官网 下载 。 由于 OpenCV 不同版本存在一定差异，本手册仅演示 4.12.0 版本。 "},"docs/环境配置.html":{"url":"docs/环境配置.html","title":"环境配置","keywords":"","body":"环境配置 在 Visual Studio Code 编辑器中开始使用 OpenCV 前，请先确保已安装好 CMake 、 MinGW ，然后分别添加到系统环境变量中。 解压下载好的 OpenCV 源码，分别将 **/opencv-4.12.0/build/x64/vc16/bin 和 **/opencv-4.12.0/build/x64/vc16/lib 两个路径添加到系统环境变量中，同时在 **/opencv-4.12.0/build/x64 下新建一个空的 opencv 目录。 打开 cmake-gui 工具，在源路径栏选择 **/opencv-4.12.0/sources 目录，在编译路径栏选择刚才新建的 **/opencv-4.12.0/build/x64/opencv 目录，然后点击 Configure ，在弹出的对话框中依次选择 MinGW Makefiles 和 Specify native compilers ，一切就绪后再选择 Generate 。 成功后切换到 **/opencv-4.12.0/build/x64/opencv 目录，打开终端提示符，运行以下命令。 minGW32-make -j8 随后执行以下命令。 minGW32-make install 以上步骤需要耐心等待，装载完成后，再将 **/opencv-4.12.0/build/x64/opencv/bin 添加到系统环境变量中。 接下来打开 Visual Studio Code 编辑器，新建开发项目，在 .vscode 目录中新建配置文件， c_cpp_properties.json 配置文件如下。 { \"configurations\": [ { \"name\": \"Win32\", \"includePath\": [ \"${workspaceFolder}/**\", \"**/opencv-4.12.0/build/include\", \"**/opencv-4.12.0/build/include/opencv2\" ], \"defines\": [ \"_DEBUG\", \"UNICODE\", \"_UNICODE\" ], \"compilerPath\": \"**/mingw64/bin/gcc.exe\", \"cStandard\": \"c17\", \"cppStandard\": \"gnu++14\", \"intelliSenseMode\": \"windows-gcc-x64\" } ], \"version\": 4 } tasks.json 配置文件如下。 { \"tasks\": [ { \"type\": \"cppbuild\", \"label\": \"C/C++: g++.exe\", \"command\": \"**/mingw64/bin/g++.exe\", \"args\": [ \"-fdiagnostics-color=always\", \"-g\", \"${file}\", \"-I\", \"**/opencv-4.12.0/build/include\", \"-I\", \"**/opencv-4.12.0/build/include/opencv2\", \"-L\", \"**/opencv-4.12.0/build/x64/opencv/lib\", \"-l\", \"libopencv_calib3d4120\", \"-l\", \"libopencv_core4120\", \"-l\", \"libopencv_dnn4120\", \"-l\", \"libopencv_features2d4120\", \"-l\", \"libopencv_flann4120\", \"-l\", \"libopencv_gapi4120\", \"-l\", \"libopencv_highgui4120\", \"-l\", \"libopencv_imgcodecs4120\", \"-l\", \"libopencv_imgproc4120\", \"-l\", \"libopencv_ml4120\", \"-l\", \"libopencv_objdetect4120\", \"-l\", \"libopencv_photo4120\", \"-l\", \"libopencv_stitching4120\", \"-l\", \"libopencv_video4120\", \"-l\", \"libopencv_videoio4120\", \"-o\", \"${fileDirname}/${fileBasenameNoExtension}.exe\" ], \"options\": { \"cwd\": \"${fileDirname}\" }, \"problemMatcher\": [ \"$gcc\" ], \"group\": { \"kind\": \"build\", \"isDefault\": true } } ], \"version\": \"2.0.0\" } 最后在项目目录中新建 main.cpp 文件，代码如下。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = imread(\"demo.jpg\"); if (img.empty()) { cout "},"docs/图像读取与显示.html":{"url":"docs/图像读取与显示.html","title":"图像读取与显示","keywords":"","body":"图像读取与显示 执行下面的代码，可以读取并显示指定的图片。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = imread(\"demo.jpg\"); if (img.empty()) { cout "},"docs/图像色彩空间转换.html":{"url":"docs/图像色彩空间转换.html","title":"图像色彩空间转换","keywords":"","body":"图像色彩空间转换 执行下面的代码，可以将指定的图片分别转换为 HSV 和灰度图。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat hsv, gray; Mat img = imread(\"demo.jpg\"); if (img.empty()) { cout "},"docs/图像创建与赋值.html":{"url":"docs/图像创建与赋值.html","title":"图像创建与赋值","keywords":"","body":"图像创建与赋值 执行下面的代码，可以克隆指定的图像矩阵。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img1, img2, img3; img1 = imread(\"demo.jpg\"); if (img1.empty()) { cout 执行下面的代码，分别以单通道与三通道方式创建指定大小的图像矩阵，所有通道均赋值为 0 。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img1 = Mat::zeros(Size(5, 5), CV_8UC1); cout 执行下面的代码，分别以单通道与三通道方式创建指定大小的图像矩阵，三通道中仅第一个通道被赋值为 1 ，其余通道均赋值为 0 。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img1 = Mat::ones(Size(5, 5), CV_8UC1); cout 执行下面的代码，为创建好的单通道与三通道图像矩阵手动赋值。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img1 = Mat::zeros(Size(5, 5), CV_8UC1); img1 = 233; cout 注意，直接使用赋值操作传递的是图像矩阵的地址引用。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img1, img2; img1 = Mat::zeros(Size(5, 5), CV_8UC3); img1 = Scalar(233, 233, 233); img2 = img1; img2 = Scalar(0, 0, 0); cout "},"docs/图像像素读写.html":{"url":"docs/图像像素读写.html","title":"图像像素读写","keywords":"","body":"图像像素读写 执行下面的代码，循环遍历图像矩阵的每个通道，并将图像置为反色。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = imread(\"demo.jpg\"); int rows, cols, channels; int i, j; int pixel; Vec3b bgr; if (img.empty()) { cout (i, j); img.at(i, j) = 255 - pixel; } if (channels == 3) { bgr = img.at(i, j); img.at(i, j)[0] = 255 - bgr[0]; img.at(i, j)[1] = 255 - bgr[1]; img.at(i, j)[2] = 255 - bgr[2]; } } } imshow(\"IMG\", img); waitKey(0); destroyAllWindows(); return 0; } 也可使用指针操作方式完成上述操作。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = imread(\"demo.jpg\"); int rows, cols, channels; int i, j; uchar *p; if (img.empty()) { cout (i); for (j = 0; j "},"docs/图像像素算术操作.html":{"url":"docs/图像像素算术操作.html","title":"图像像素算术操作","keywords":"","body":"图像像素算术操作 执行下面的代码，可以对图像矩阵的每个通道进行像素算术操作。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img, img1, img2, img3, img4; img = imread(\"demo.jpg\"); if (img.empty()) { cout 也可以使用内置提供的 API 。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img, img1, img2, img3, img4; img = imread(\"demo.jpg\"); if (img.empty()) { cout "},"docs/滚动条操作案例.html":{"url":"docs/滚动条操作案例.html","title":"滚动条操作案例","keywords":"","body":"滚动条操作案例 执行下面的代码，通过操作滚动条实时调整图像的亮度。 #include #include using namespace cv; using namespace std; Mat img, result; int brightness = 50; int _brightness = 0; void callback_brightness(int brightness, void *) { _brightness = brightness - 50; cout 继续修改代码，实现同时调整亮度与对比度。 #include #include using namespace cv; using namespace std; Mat img, result; int brightness = 50; int _brightness = 0; int contrast = 50; double _contrast = 1.0; void callback_brightness(int brightness, void *) { _brightness = brightness - 50; cout "},"docs/键盘操作案例.html":{"url":"docs/键盘操作案例.html","title":"键盘操作案例","keywords":"","body":"键盘操作案例 执行下面的代码，当键盘输入 1 时将原图片转换为 HSV ，当键盘输入 2 时将原图片转换为灰度图，按下键盘 Esc 时程序退出。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = imread(\"demo.jpg\"); Mat result = img.clone(); int k; if (img.empty()) { cout "},"docs/颜色表操作.html":{"url":"docs/颜色表操作.html","title":"颜色表操作","keywords":"","body":"颜色表操作 执行下面的代码，每隔一定时间在原图片上应用不同风格的色彩映射。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = imread(\"demo.jpg\"); Mat result = img.clone(); int k; int index = 0; int colormap[] = {COLORMAP_SPRING, COLORMAP_SUMMER, COLORMAP_AUTUMN, COLORMAP_WINTER, COLORMAP_PINK, COLORMAP_OCEAN}; if (img.empty()) { cout "}}