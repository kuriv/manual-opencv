{"./":{"url":"./","title":"OpenCV","keywords":"","body":"OpenCV OpenCV 是世界上最大的计算机视觉库。 "},"docs/安装 OpenCV.html":{"url":"docs/安装 OpenCV.html","title":"安装 OpenCV","keywords":"","body":"安装 OpenCV 要了解更多选择，可以前往 OpenCV 官网 下载 。 由于 OpenCV 不同版本存在一定差异，本手册仅演示 4.12.0 版本。 "},"docs/环境配置.html":{"url":"docs/环境配置.html","title":"环境配置","keywords":"","body":"环境配置 在 Visual Studio Code 编辑器中开始使用 OpenCV 前，请先确保已安装好 CMake 、 MinGW ，然后分别添加到系统环境变量中。 解压下载好的 OpenCV 源码，分别将 **/opencv-4.12.0/build/x64/vc16/bin 和 **/opencv-4.12.0/build/x64/vc16/lib 两个路径添加到系统环境变量中，同时在 **/opencv-4.12.0/build/x64 下新建一个空的 opencv 目录。 打开 cmake-gui 工具，在源路径栏选择 **/opencv-4.12.0/sources 目录，在编译路径栏选择刚才新建的 **/opencv-4.12.0/build/x64/opencv 目录，然后点击 Configure ，在弹出的对话框中依次选择 MinGW Makefiles 和 Specify native compilers ，一切就绪后再选择 Generate 。 成功后切换到 **/opencv-4.12.0/build/x64/opencv 目录，打开终端提示符，分别运行以下命令，期间耐心等待。 minGW32-make -j8 minGW32-make install 装载完成后，再将 **/opencv-4.12.0/build/x64/opencv/bin 添加到系统环境变量中。 接下来打开 Visual Studio Code 编辑器，新建开发项目，在 .vscode 目录中新建 c_cpp_properties.json 配置文件如下。 { \"configurations\": [ { \"name\": \"Win32\", \"includePath\": [ \"${workspaceFolder}/**\", \"**/opencv-4.12.0/build/include\", \"**/opencv-4.12.0/build/include/opencv2\" ], \"defines\": [ \"_DEBUG\", \"UNICODE\", \"_UNICODE\" ], \"compilerPath\": \"**/mingw64/bin/gcc.exe\", \"cStandard\": \"c17\", \"cppStandard\": \"gnu++14\", \"intelliSenseMode\": \"windows-gcc-x64\" } ], \"version\": 4 } 新建 tasks.json 配置文件如下。 { \"tasks\": [ { \"type\": \"cppbuild\", \"label\": \"C/C++: g++.exe\", \"command\": \"**/mingw64/bin/g++.exe\", \"args\": [ \"-fdiagnostics-color=always\", \"-g\", \"${file}\", \"-I\", \"**/opencv-4.12.0/build/include\", \"-I\", \"**/opencv-4.12.0/build/include/opencv2\", \"-L\", \"**/opencv-4.12.0/build/x64/opencv/lib\", \"-l\", \"libopencv_calib3d4120\", \"-l\", \"libopencv_core4120\", \"-l\", \"libopencv_dnn4120\", \"-l\", \"libopencv_features2d4120\", \"-l\", \"libopencv_flann4120\", \"-l\", \"libopencv_gapi4120\", \"-l\", \"libopencv_highgui4120\", \"-l\", \"libopencv_imgcodecs4120\", \"-l\", \"libopencv_imgproc4120\", \"-l\", \"libopencv_ml4120\", \"-l\", \"libopencv_objdetect4120\", \"-l\", \"libopencv_photo4120\", \"-l\", \"libopencv_stitching4120\", \"-l\", \"libopencv_video4120\", \"-l\", \"libopencv_videoio4120\", \"-o\", \"${fileDirname}/${fileBasenameNoExtension}.exe\" ], \"options\": { \"cwd\": \"${fileDirname}\" }, \"problemMatcher\": [ \"$gcc\" ], \"group\": { \"kind\": \"build\", \"isDefault\": true } } ], \"version\": \"2.0.0\" } 最后在项目目录中新建 main.cpp 文件，代码如下。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = imread(\"demo.jpg\"); if (img.empty()) { cout "},"docs/模块架构.html":{"url":"docs/模块架构.html","title":"模块架构","keywords":"","body":"模块架构 打开 OpenCV 文件夹，在 **/opencv-4.12.0/build/include/opencv2 目录下包含许多功能模块。 calib3d 该模块是由 calibration 和 3D 两个术语的缩写组合而成，主要包含相机标定与立体视觉等功能，如物体位姿估计、三维重建、摄像头标定等。 core 该模块为核心功能模块，主要包含 OpenCV 库的基础结构以及基本操作，如 OpenCV 基本数据结构、绘图函数、数组操作等。 dnn 该模块为深度学习模块，主要包含构建神经网络、加载序列化网络模型等功能。 features2d 该模块是由 features 和 2D 两个术语的缩写组合而成，主要包含特征检测、描述与匹配等功能。 flann 该模块是 Fast Library for Approximate Nearest Neighbors 的缩写，主要包含快速近似近邻搜索与聚类等。 gapi 该模块主要作为框架，旨在加速常规的图像处理。 highgui 该模块是高层 GUI ，主要包含创建和操作显示图像的窗口、处理鼠标事件以及键盘命令、提供图形交互可视化界面等。 imgcodecs 该模块主要包含图像文件读取与保存等功能。 imgproc 该模块是由 image 和 process 两个单词的缩写组成而成，主要包含图像滤波、几何变换、直方图、特征检测与目标检测等。 ml 该模块为机器学习模块，主要包含统计分类、回归和数据聚类等功能。 objdetect 该模块为目标检测模块，主要包含图像目标检测等功能。 photo 该模块为计算摄影模块，主要包含图像修复和去噪等工作。 stitching 该模块为图像拼接模块，主要包含特征点寻找与匹配算法、估计旋转、自动校准、接缝估计等功能。 video 该模块为视频分析模块，主要包含运动估计、背景分离、对象跟踪等功能。 videoio 该模块为视频输入/输出模块，主要包含读取/写入视频或图像序列等功能。 "},"docs/数据载入、显示与保存.html":{"url":"docs/数据载入、显示与保存.html","title":"数据载入、显示与保存","keywords":"","body":"数据载入、显示与保存 "},"docs/数据载入、显示与保存/图像存储容器.html":{"url":"docs/数据载入、显示与保存/图像存储容器.html","title":"图像存储容器","keywords":"","body":"图像存储容器 执行下面的代码，创建一个 512 * 512 大小的 8 位无符号整数的单通道矩阵。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img(512, 512, CV_8UC1); return 0; } 执行下面的代码，创建一个 512 * 512 大小的 8 位无符号整数的三通道矩阵，用于存放彩色图像。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img(512, 512, CV_8UC3); return 0; } 执行下面的代码，根据输入尺寸和类型构造矩阵。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img(Size(512, 512), CV_8UC3); return 0; } 执行下面的代码，利用已有矩阵构造新的矩阵。注意，这种方式构造的矩阵与原矩阵指向的是同一地址。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img1(512, 512, CV_8UC3); Mat img2(img1); return 0; } 执行下面的代码，从原矩阵中截取新矩阵。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img1(512, 512, CV_8UC3); Mat img2(img1, Range(50, 100)); return 0; } 执行下面的代码，在构造矩阵同时进行赋值。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img1(512, 512, CV_8UC1, Scalar(255)); Mat img2(512, 512, CV_8UC3, Scalar(0, 0, 255)); return 0; } 执行下面的代码，利用枚举法为矩阵赋值。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = (Mat_(3, 3) 执行下面的代码，利用数组为矩阵赋值。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { float arr[] = {5, 6, 7, 8, 1, 2, 3, 4}; Mat img1(Size(2, 4), CV_32FC1, arr); cout 也可以利用类方法对矩阵进行快速赋值。执行下面的代码，构建一个全为 0 的矩阵。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img1 = Mat::zeros(Size(5, 5), CV_8UC1); cout 执行下面的代码，构建一个全为 1 的矩阵。注意，三通道中仅第一个通道被赋值为 1 ，其余通道均为 0 。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img1 = Mat::ones(Size(5, 5), CV_8UC1); cout 执行下面的代码，构建一个单位矩阵。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img1 = Mat::eye(Size(5, 5), CV_8UC1); cout 执行下面的代码，构建对角矩阵。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat diag = (Mat_(1, 5) 执行下面的代码，对矩阵进行加减乘除运算。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat a = (Mat_(3, 3) (3, 3) 执行下面的代码，对两个矩阵进行乘法运算。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat a = (Mat_(2, 2) (2, 2) 执行下面的代码，分别获取矩阵的相关信息。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img(3, 4, CV_8UC3); cout 执行下面的代码，获取单通道矩阵中元素的信息。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = (Mat_(3, 3) (1, 1) 执行下面的代码，获取三通道矩阵中元素的信息。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = Mat(3, 3, CV_8UC3, Scalar(0, 0, 255)); Vec3b bgr = img.at(1, 1); cout 也可以通过指针方式读取矩阵中元素的信息。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = Mat(3, 3, CV_8UC3, Scalar(0, 0, 255)); int rows = img.rows; int cols = img.cols; uchar *p; int i, j; for (i = 0; i (i); for (j = 0; j "},"docs/数据载入、显示与保存/图像读取显示.html":{"url":"docs/数据载入、显示与保存/图像读取显示.html","title":"图像读取显示","keywords":"","body":"图像读取显示 执行下面的代码，读取指定的图像。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = imread(\"demo.jpg\"); if (img.empty()) { cout 执行下面的代码，为生成的窗口指定窗口名和窗口属性。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { namedWindow(\"IMG\", WINDOW_FREERATIO); return 0; } 执行下面的代码，读取并显示指定的图像。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = imread(\"demo.jpg\"); if (img.empty()) { cout "},"docs/数据载入、显示与保存/视频加载与摄像头调用.html":{"url":"docs/数据载入、显示与保存/视频加载与摄像头调用.html","title":"视频加载与摄像头调用","keywords":"","body":"视频加载与摄像头调用 执行下面的代码，读取并显示指定的视频，同时输出视频的基本信息。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { VideoCapture video(\"demo.mp4\"); Mat img; int k; if (video.isOpened()) { cout > img; if (img.empty()) { break; } imshow(\"VIDEO\", img); k = waitKey(1000 / video.get(CAP_PROP_FPS)); if (k == 27) { break; } } waitKey(0); destroyAllWindows(); return 0; } 执行下面的代码，直接调用本机摄像头。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { VideoCapture video(0); Mat img; int k; if (video.isOpened()) { cout > img; if (img.empty()) { break; } imshow(\"VIDEO\", img); k = waitKey(1); if (k == 27) { break; } } waitKey(0); destroyAllWindows(); return 0; } "},"docs/数据载入、显示与保存/数据保存.html":{"url":"docs/数据载入、显示与保存/数据保存.html","title":"数据保存","keywords":"","body":"数据保存 执行下面的代码，将三通道矩阵信息保存为图像。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img(512, 512, CV_8UC3, Scalar(255, 0, 255)); imshow(\"IMG\", img); if (!imwrite(\"demo.png\", img)) { cout "},"docs/图像缩放.html":{"url":"docs/图像缩放.html","title":"图像缩放","keywords":"","body":"图像缩放 执行下面的代码，将原图像进行等比例放大和缩小。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img; Mat zoomin, zoomout; img = imread(\"demo.jpg\"); if (img.empty()) { cout "},"docs/图像翻转.html":{"url":"docs/图像翻转.html","title":"图像翻转","keywords":"","body":"图像翻转 执行下面的代码，将原图像分别进行垂直翻转、水平翻转以及 180° 旋转。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = imread(\"demo.jpg\"); Mat img1, img2, img3; if (img.empty()) { cout "},"docs/图像旋转.html":{"url":"docs/图像旋转.html","title":"图像旋转","keywords":"","body":"图像旋转 "},"docs/图像色彩空间转换.html":{"url":"docs/图像色彩空间转换.html","title":"图像色彩空间转换","keywords":"","body":"图像色彩空间转换 执行下面的代码，可以将指定的图片分别转换为 HSV 和灰度图。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat hsv, gray; Mat img = imread(\"demo.jpg\"); if (img.empty()) { cout 执行下面的代码，可以实现简单抠图以及更换图片背景色效果，注意 HSV 基本颜色分量范围需依据实际情况决定。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = imread(\"demo_1.jpg\"); Mat hsv, mask, background; if (img.empty()) { cout "},"docs/图像创建与赋值.html":{"url":"docs/图像创建与赋值.html","title":"图像创建与赋值","keywords":"","body":"图像创建与赋值 执行下面的代码，可以克隆指定的图像矩阵。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img1, img2, img3; img1 = imread(\"demo.jpg\"); if (img1.empty()) { cout 执行下面的代码，分别以单通道与三通道方式创建指定大小的图像矩阵，所有通道均赋值为 0 。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img1 = Mat::zeros(Size(5, 5), CV_8UC1); cout 执行下面的代码，分别以单通道与三通道方式创建指定大小的图像矩阵，三通道中仅第一个通道被赋值为 1 ，其余通道均赋值为 0 。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img1 = Mat::ones(Size(5, 5), CV_8UC1); cout 执行下面的代码，为创建好的单通道与三通道图像矩阵手动赋值。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img1 = Mat::zeros(Size(5, 5), CV_8UC1); img1 = 233; cout 执行下面的代码，为创建好的三通道图像矩阵绘制指定大小与颜色的矩阵。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = Mat::zeros(Size(256, 256), CV_8UC3); rectangle(img, Rect(100, 100, 80, 80), Scalar(0, 0, 255), -1); imshow(\"IMG\", img); waitKey(0); destroyAllWindows(); return 0; } 注意，直接使用赋值操作传递的是图像矩阵的地址引用。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img1, img2; img1 = Mat::zeros(Size(5, 5), CV_8UC3); img1 = Scalar(233, 233, 233); img2 = img1; img2 = Scalar(0, 0, 0); cout "},"docs/图像像素读写.html":{"url":"docs/图像像素读写.html","title":"图像像素读写","keywords":"","body":"图像像素读写 执行下面的代码，循环遍历图像矩阵的每个通道，并将图像置为反色。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = imread(\"demo.jpg\"); int rows, cols, channels; int i, j; int pixel; Vec3b bgr; if (img.empty()) { cout (i, j); img.at(i, j) = 255 - pixel; } if (channels == 3) { bgr = img.at(i, j); img.at(i, j)[0] = 255 - bgr[0]; img.at(i, j)[1] = 255 - bgr[1]; img.at(i, j)[2] = 255 - bgr[2]; } } } imshow(\"IMG\", img); waitKey(0); destroyAllWindows(); return 0; } 也可使用指针操作方式完成上述操作。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = imread(\"demo.jpg\"); int rows, cols, channels; int i, j; uchar *p; if (img.empty()) { cout (i); for (j = 0; j "},"docs/图像像素算术操作.html":{"url":"docs/图像像素算术操作.html","title":"图像像素算术操作","keywords":"","body":"图像像素算术操作 执行下面的代码，可以对图像矩阵的每个通道进行像素算术操作。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img, img1, img2, img3, img4; img = imread(\"demo.jpg\"); if (img.empty()) { cout 也可以使用内置提供的 API 。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img, img1, img2, img3, img4; img = imread(\"demo.jpg\"); if (img.empty()) { cout "},"docs/图像像素逻辑操作.html":{"url":"docs/图像像素逻辑操作.html","title":"图像像素逻辑操作","keywords":"","body":"图像像素逻辑操作 执行下面的代码，可以对图像矩阵进行像素逻辑操作。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img1 = Mat::zeros(Size(256, 256), CV_8UC3); Mat img2 = Mat::zeros(Size(256, 256), CV_8UC3); Mat result; rectangle(img1, Rect(100, 100, 80, 80), Scalar(0, 255, 255), -1); rectangle(img2, Rect(150, 150, 80, 80), Scalar(255, 255, 0), -1); imshow(\"IMG1\", img1); imshow(\"IMG2\", img2); bitwise_and(img1, img2, result); imshow(\"AND\", result); bitwise_or(img1, img2, result); imshow(\"OR\", result); bitwise_xor(img1, img2, result); imshow(\"XOR\", result); bitwise_not(img1, result); imshow(\"NOT\", result); waitKey(0); destroyAllWindows(); return 0; } "},"docs/图像像素值统计.html":{"url":"docs/图像像素值统计.html","title":"图像像素值统计","keywords":"","body":"图像像素值统计 执行下面的代码，输出原图像在每个通道中的像素最小值、最大值以及分别所在的坐标。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = imread(\"demo.jpg\"); vector matrix; double min, max; Point minLoc, maxLoc; if (img.empty()) { cout 执行下面的代码，计算指定图像矩阵的平均差与标准差。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = imread(\"demo.jpg\"); Mat mean, stddev; if (img.empty()) { cout "},"docs/滚动条操作案例.html":{"url":"docs/滚动条操作案例.html","title":"滚动条操作案例","keywords":"","body":"滚动条操作案例 执行下面的代码，通过操作滚动条实时调整图像的亮度。 #include #include using namespace cv; using namespace std; Mat img, result; int brightness = 50; int _brightness = 0; void callback_brightness(int brightness, void *) { _brightness = brightness - 50; cout 继续修改代码，实现同时调整亮度与对比度。 #include #include using namespace cv; using namespace std; Mat img, result; int brightness = 50; int _brightness = 0; int contrast = 50; double _contrast = 1.0; void callback_brightness(int brightness, void *) { _brightness = brightness - 50; cout "},"docs/键盘操作案例.html":{"url":"docs/键盘操作案例.html","title":"键盘操作案例","keywords":"","body":"键盘操作案例 执行下面的代码，当键盘输入 1 时将原图像转换为 HSV ，当键盘输入 2 时将原图像转换为灰度图，按下键盘 Esc 时程序退出。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = imread(\"demo.jpg\"); Mat result = img.clone(); int k; if (img.empty()) { cout "},"docs/鼠标操作案例.html":{"url":"docs/鼠标操作案例.html","title":"鼠标操作案例","keywords":"","body":"鼠标操作案例 执行下面的代码，鼠标选中任意区域实现图片裁剪功能。 #include #include using namespace cv; using namespace std; Mat img, result; Point p1, p2, p3, p4; vector p; Rect roi; bool flag = false; void show(int x, int y) { img.copyTo(result); if (x p1.x && p3.y p1.x && p3.y > p1.y) // rb { p2.x = p3.x; p2.y = p1.y; p4.x = p1.x; p4.y = p3.y; roi.x = p1.x; roi.y = p1.y; roi.width = p3.x - p1.x; roi.height = p3.y - p1.y; } else if (p3.x p1.y) // lb { p2.x = p1.x; p2.y = p3.y; p4.x = p3.x; p4.y = p1.y; roi.x = p3.x; roi.y = p1.y; roi.width = p1.x - p3.x; roi.height = p3.y - p1.y; } else { return; } cout > contours; contours.clear(); contours.push_back(p); drawContours(result, contours, 0, Scalar(255, 255, 255), 1, LINE_AA); imshow(\"IMG\", result); } void callback_mouse(int event, int x, int y, int flags, void *) { if (event == EVENT_LBUTTONDOWN) { flag = true; imshow(\"IMG\", img); p1.x = x; p1.y = y; } else if (flag && event == EVENT_LBUTTONUP) { show(x, y); flag = false; imshow(\"ROI\", img(roi)); } else if (flag && event == EVENT_MOUSEMOVE) { show(x, y); } } int main(int argc, char const *argv[]) { img = imread(\"demo.jpg\"); if (img.empty()) { cout "},"docs/颜色表操作.html":{"url":"docs/颜色表操作.html","title":"颜色表操作","keywords":"","body":"颜色表操作 执行下面的代码，每隔一定时间在原图片上应用不同风格的色彩映射。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = imread(\"demo.jpg\"); Mat result = img.clone(); int k; int index = 0; int colormap[] = {COLORMAP_SPRING, COLORMAP_SUMMER, COLORMAP_AUTUMN, COLORMAP_WINTER, COLORMAP_PINK, COLORMAP_OCEAN}; if (img.empty()) { cout "},"docs/通道分离与合并.html":{"url":"docs/通道分离与合并.html","title":"通道分离与合并","keywords":"","body":"通道分离与合并 执行下面的代码，将原图片从三通道中分离展示，并进行自定义组合。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = imread(\"demo.jpg\"); Mat result; vector matrix; if (img.empty()) { cout 也可以指定要复制和输出的通道。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = imread(\"demo.jpg\"); Mat result = img.clone(); int from_to[] = {0, 2, 1, 1, 2, 0}; if (img.empty()) { cout "},"docs/几何图形绘制.html":{"url":"docs/几何图形绘制.html","title":"几何图形绘制","keywords":"","body":"几何图形绘制 执行下面的代码，在原图像上绘制矩形。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = imread(\"demo.jpg\"); Rect rect; rect.x = 100; rect.y = 100; rect.width = 200; rect.height = 300; if (img.empty()) { cout 执行下面的代码，在原图像上绘制圆形。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = imread(\"demo.jpg\"); if (img.empty()) { cout 执行下面的代码，在原图像上绘制线段。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = imread(\"demo.jpg\"); if (img.empty()) { cout 执行下面的代码，在原图像上绘制椭圆形。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = imread(\"demo.jpg\"); RotatedRect rrect; rrect.center = Point(200, 200); rrect.size = Size(100, 200); rrect.angle = 0; if (img.empty()) { cout "},"docs/多边形绘制.html":{"url":"docs/多边形绘制.html","title":"多边形绘制","keywords":"","body":"多边形绘制 执行下面的代码，在原图像上绘制多边形。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = imread(\"demo.jpg\"); Point p1 = Point(100, 100); Point p2 = Point(200, 50); Point p3 = Point(300, 200); Point p4 = Point(250, 300); Point p5 = Point(200, 100); Point p6 = Point(150, 80); vector p; p.push_back(p1); p.push_back(p2); p.push_back(p3); p.push_back(p4); p.push_back(p5); p.push_back(p6); if (img.empty()) { cout 也可以使用下面的方式绘制并填充。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = imread(\"demo.jpg\"); Point p1 = Point(100, 100); Point p2 = Point(200, 50); Point p3 = Point(300, 200); Point p4 = Point(250, 300); Point p5 = Point(200, 100); Point p6 = Point(150, 80); vector p; p.push_back(p1); p.push_back(p2); p.push_back(p3); p.push_back(p4); p.push_back(p5); p.push_back(p6); vector> contours; contours.push_back(p); if (img.empty()) { cout "},"docs/随机数与随机颜色.html":{"url":"docs/随机数与随机颜色.html","title":"随机数与随机颜色","keywords":"","body":"随机数与随机颜色 执行下面的代码，在原图像上随机绘制线段。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img = Mat::zeros(Size(512, 512), CV_8UC3); img = Scalar(0, 0, 0); int rows = img.rows, cols = img.cols; int k; RNG rng(233); int x1, x2, y1, y2; int b, g, r; while (true) { img = Scalar(0, 0, 0); k = waitKey(100); if (k == 27) { break; } x1 = rng.uniform(0, rows); x2 = rng.uniform(0, rows); y1 = rng.uniform(0, cols); y2 = rng.uniform(0, cols); b = rng.uniform(0, 255); g = rng.uniform(0, 255); r = rng.uniform(0, 255); line(img, Point(x1, y1), Point(x2, y2), Scalar(b, g, r), 1); imshow(\"IMG\", img); } waitKey(0); destroyAllWindows(); return 0; } "},"docs/图像数据归一化.html":{"url":"docs/图像数据归一化.html","title":"图像数据归一化","keywords":"","body":"图像数据归一化 在图像处理中，归一化是一种常见的预处理步骤。执行下面的代码，将原图像像素值范围从 [0, 255] 归一化到 [0, 1] 范围。 #include #include using namespace cv; using namespace std; int main(int argc, char const *argv[]) { Mat img1, img2; img1 = imread(\"demo.jpg\"); if (img1.empty()) { cout "}}